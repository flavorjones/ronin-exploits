require 'spec_helper'
require 'ronin/exploits/loot'

require 'tmpdir'

describe Ronin::Exploits::Loot do
  describe "#initialize" do
    it "must initialize the loot store to being empty" do
      expect(subject).to be_empty
    end
  end

  describe "#add" do
    let(:path)     { 'test.txt' }
    let(:contents) { 'this is a set' }

    it "must add a File to the loot store with the given path and contents" do
      subject.add(path,contents)

      expect(subject[path]).to be_kind_of(described_class::File)
      expect(subject[path].contents).to eq(contents)
    end

    context "when the format: keyword argument is given" do
      let(:format) { :json }

      it "must set the #format of the loot file" do
        subject.add(path,contents, format: format)

        expect(subject[path]).to be_kind_of(described_class::File)
        expect(subject[path].format).to be(format)
      end
    end
  end

  describe "#[]" do
    context "when given a path of a previously added loot file" do
      let(:path)     { 'test.txt' }
      let(:contents) { 'this is a set' }

      before { subject.add(path,contents) }

      it "must return the #{described_class}::File object for the given path" do
        expect(subject[path]).to be_kind_of(described_class::File)
        expect(subject[path].contents).to eq(contents)
      end
    end

    context "when the given path does not map to a loot file in the loot store" do
      let(:path) { 'foo' }

      it "must return nil" do
        expect(subject[path]).to be(nil)
      end
    end
  end

  describe "#each" do
    let(:path1)     { 'test1.txt' }
    let(:contents1) { 'test 1' }

    let(:path2)     { 'test2.txt' }
    let(:contents2) { 'test 2' }

    before do
      subject.add(path1,contents1)
      subject.add(path2,contents2)
    end

    context "when given a block" do
      it "must yield every #{described_class}::File in the loot store" do
        expect { |b|
          subject.each(&b)
        }.to yield_successive_args(subject[path1], subject[path2])
      end
    end

    context "when no block is given" do
      it "must return an Enumerator for #each" do
        expect(subject.each.to_a).to eq([subject[path1], subject[path2]])
      end
    end
  end

  describe "#empty?" do
    context "when the loot store contains loot files" do
      let(:path)     { 'test.txt' }
      let(:contents) { 'this is a set' }

      before { subject.add(path,contents) }

      it "must return false" do
        expect(subject.empty?).to be(false)
      end
    end

    context "when the loot store does not contain loot files" do
      it "must return true" do
        expect(subject.empty?).to be(true)
      end
    end
  end

  describe "#save" do
    context "when the loot store contains loot files" do
      let(:path1)     { 'test1.txt' }
      let(:contents1) { 'test 1' }

      let(:path2)     { 'test2.txt' }
      let(:contents2) { 'test 2' }

      let(:output_dir) { Dir.mktmpdir('ronin-exploits-loot') }

      before do
        subject.add(path1,contents1)
        subject.add(path2,contents2)
        subject.save(output_dir)
      end

      it "must save each loot file into the output directory" do
        expect(File.read(File.join(output_dir,path1))).to eq(contents1)
        expect(File.read(File.join(output_dir,path2))).to eq(contents2)
      end
    end

    context "when the loot store is empty" do
      let(:output_dir) do
        File.join(Dir.mktmpdir('ronin-exploits-loot'),'new_dir')
      end

      before { subject.save(output_dir) }

      it "must still create the output directory" do
        expect(File.directory?(output_dir)).to be(true)
      end
    end
  end
end
