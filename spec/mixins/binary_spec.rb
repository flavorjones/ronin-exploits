require 'spec_helper'
require 'ronin/exploits/mixins/binary'

require 'ronin/exploits/exploit'
require 'ronin/exploits/metadata/arch'
require 'ronin/exploits/metadata/os'

describe Ronin::Exploits::Mixins::Binary do
  module TestBinaryMixin
    class ExploitWithArchSet < Ronin::Exploits::Exploit
      include Ronin::Exploits::Metadata::Arch
      include Ronin::Exploits::Mixins::Binary

      arch :x86
    end

    class ExploitWithoutArch < Ronin::Exploits::Exploit
      include Ronin::Exploits::Mixins::Binary
    end

    class ExploitWithoutArchSet < Ronin::Exploits::Exploit
      include Ronin::Exploits::Metadata::Arch
      include Ronin::Exploits::Mixins::Binary
    end

    class ExploitWithArchSetButWithoutOSSet < Ronin::Exploits::Exploit
      include Ronin::Exploits::Metadata::Arch
      include Ronin::Exploits::Metadata::OS
      include Ronin::Exploits::Mixins::Binary

      arch :x86
    end

    class ExploitWithArchAndOSSet < Ronin::Exploits::Exploit
      include Ronin::Exploits::Metadata::Arch
      include Ronin::Exploits::Metadata::OS
      include Ronin::Exploits::Mixins::Binary

      arch :x86
      os :linux
    end
  end

  subject { exploit_class.new }

  describe "#perform_validate" do
    context "when the exploit class does not define an #arch method" do
      let(:exploit_class) { TestBinaryMixin::ExploitWithoutArch }

      it do
        expect {
          subject.perform_validate
        }.to raise_error(Ronin::Exploits::ValidationError,"exploit #{exploit_class} did not include Ronin::Exploits::Metadata::Arch or Ronin::Exploits::Mixins::HasTargets")
      end
    end

    context "when the exploit class's #arch method returns nil" do
      let(:exploit_class) { TestBinaryMixin::ExploitWithoutArchSet }

      it do
        expect {
          subject.perform_validate
        }.to raise_error(Ronin::Exploits::ValidationError,"exploit #{exploit_class} did not include define an architecture")
      end
    end

    context "when the exploit class defines an architecture" do
      let(:exploit_class) { TestBinaryMixin::ExploitWithArchSet }

      it do
        expect {
          subject.perform_validate
        }.to_not raise_error
      end
    end
  end

  describe "#platform" do
    context "when #arch returns nil" do
      let(:exploit_class) { TestBinaryMixin::ExploitWithoutArchSet }

      it "must return Ronin::Support::Binary::CTypes" do
        expect(subject.platform).to be(Ronin::Support::Binary::CTypes)
      end
    end

    context "when #arch returns a architecture name" do
      let(:exploit_class) { TestBinaryMixin::ExploitWithArchSet }

      it "must return the according Ronin::Support::Binary::CTypes::Arch:: module" do
        expect(subject.platform).to be(Ronin::Support::Binary::CTypes::Arch::X86)
      end

      context "and when #os is defined" do
        context "and it returns an OS name" do
          let(:exploit_class) do
            TestBinaryMixin::ExploitWithArchAndOSSet
          end

          it "must return the according Ronin::Support::Binary::CTypes::OS object with the according Ronin::Support::Binary::CTypes::Arch:: module inside it" do
            expect(subject.platform).to be_kind_of(Ronin::Support::Binary::CTypes::OS::Linux)
            expect(subject.platform.types).to be(Ronin::Support::Binary::CTypes::Arch::X86)
          end
        end

        context "but it returns nil" do
          let(:exploit_class) do
            TestBinaryMixin::ExploitWithArchSetButWithoutOSSet
          end

          it "must still return the according Ronin::Support::Binary::CTypes::Arch:: module" do
            expect(subject.platform).to be(Ronin::Support::Binary::CTypes::Arch::X86)
          end
        end
      end
    end
  end

  describe "#pack" do
    let(:exploit_class) { TestBinaryMixin::ExploitWithArchSet }

    let(:type)  { :uint32    }
    let(:value) { 0x12345678 }

    it "must pack the value using the type from #platform" do
      expect(subject.pack(type,value)).to eq("\x78\x56\x34\x12".b)
    end
  end
end
