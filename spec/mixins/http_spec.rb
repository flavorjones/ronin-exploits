require 'spec_helper'
require 'ronin/exploits/mixins/http'
require 'ronin/exploits/exploit'

describe Ronin::Exploits::Mixins::HTTP do
  module TestMixinsHTTP
    class TestExploit < Ronin::Exploits::Exploit
      include Ronin::Exploits::Mixins::HTTP
    end
  end

  let(:test_class) { TestMixinsHTTP::TestExploit }

  describe ".included" do
    subject { test_class }

    it "must define a 'http_proxy' param" do
      expect(subject.params[:http_proxy]).to_not be_nil
      expect(subject.params[:http_proxy].desc).to eq("The HTTP proxy to use")
    end

    it "must define a 'user_agent' param" do
      expect(subject.params[:user_agent]).to_not be_nil
      expect(subject.params[:user_agent].type).to be_kind_of(Ronin::Core::Params::Types::Enum)
      expect(subject.params[:user_agent].type.values).to eq(
        [
          :random,
          :chrome,
          :firefox,
          :safari,
          :linux,
          :macos,
          :windows,
          :iphone,
          :ipad,
          :android
        ] + Ronin::Support::Network::HTTP::UserAgents::ALIASES.keys
      )
      expect(subject.params[:user_agent].desc).to eq("The HTTP User-Agent to select")
    end

    it "must define a 'raw_user_agent' param" do
      expect(subject.params[:raw_user_agent]).to_not be_nil
      expect(subject.params[:raw_user_agent].desc).to eq("The raw HTTP User-Agent string to use")
    end
  end

  let(:base_url) { URI.parse("https://www.example.com/base") }

  subject do
    test_class.new(params: {base_url: base_url})
  end

  describe "#url_for" do
    context "when given an absolute path" do
      let(:path) { '/foo' }

      it "must return a URI::HTTP object" do
        expect(subject.url_for(path)).to be_kind_of(URI::HTTP)
      end

      it "must override the path of the params[:base_url]" do
        expect(subject.url_for(path).path).to eq(path)
      end
    end

    context "when given a relative path" do
      let(:path) { 'foo' }

      it "must return a URI::HTTP object" do
        expect(subject.url_for(path)).to be_kind_of(URI::HTTP)
      end

      it "must convert the path into an absolute path" do
        expect(subject.url_for(path).path).to eq("/#{path}")
      end
    end

    context "when given a fully qualified URL" do
      let(:url) { "https://www.other.com/foo" }

      it "must return the URL" do
        expect(subject.url_for(url).to_s).to eq(url)
      end
    end
  end

  describe "#http_proxy" do
    let(:proxy) { 'http://example.com:8080' }

    subject do
      test_class.new(params: {base_url: base_url, http_proxy: proxy})
    end

    it "must return params[:http_proxy]" do
      expect(subject.http_proxy).to be(subject.params[:http_proxy])
    end
  end

  describe "#http_user_agent" do
    context "when params[:user_agent] is set" do
      let(:user_agent) { :random }

      subject do
        test_class.new(
          params: {
            base_url:   base_url,
            user_agent: user_agent
          }
        )
      end

      it "must return params[:user_agent]" do
        expect(subject.http_user_agent).to be(subject.params[:user_agent])
      end
    end

    context "when params[:raw_user_agent] is set" do
      let(:raw_user_agent) { 'Mozilla/5.0 Foo Bar' }

      subject do
        test_class.new(
          params: {
            base_url:       base_url,
            raw_user_agent: raw_user_agent
          }
        )
      end

      it "must return params[:raw_user_agent]" do
        expect(subject.http_user_agent).to be(
          subject.params[:raw_user_agent]
        )
      end
    end

    context "when both params[:user_agent] and params[:raw_user_agent] are set" do
      let(:user_agent)     { :random }
      let(:raw_user_agent) { 'Mozilla/5.0 Foo Bar' }

      subject do
        test_class.new(
          params: {
            base_url:          base_url,
            user_agent:        user_agent,
            raw_user_agent: raw_user_agent
          }
        )
      end

      it "must return params[:raw_user_agent]" do
        expect(subject.http_user_agent).to be(
          subject.params[:raw_user_agent]
        )
      end
    end
  end

  let(:proxy)          { URI('https://proxy.example.com:8080') }
  let(:raw_user_agent) { 'Mozilla/5.0 Foo Bar' }
  let(:user)           { 'bob' }
  let(:password)       { 'secret' }

  subject do
    test_class.new(
      params: {
        base_url:       base_url,
        http_proxy:     proxy,
        raw_user_agent: raw_user_agent,
        http_user:      user,
        http_password:  password
      }
    )
  end

  describe "#http_connect" do
    context "when given no arguments" do
      it "must call Ronin::Support::Network::HTTP.connect with #host, #port, proxy: #http_proxy, ssl: ..., user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:connect).with(
          subject.host, subject.port, proxy:      subject.http_proxy,
                                      ssl:        base_url.scheme == 'https',
                                      user_agent: subject.http_user_agent
        )

        subject.http_connect
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          allow(Ronin::Support::Network::HTTP).to receive(:connect).with(
            subject.host, subject.port, proxy:      subject.http_proxy,
                                        ssl:        base_url.scheme == 'https',
                                        user_agent: subject.http_user_agent
          )

          expect(subject).to receive(:print_debug).with(
            "Connecting to #{subject.host}:#{subject.port} ..."
          )

          subject.http_connect
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http" do
    it "must call Ronin::Support::Network::HTTP.connect with #host, #port, proxy: #http_proxy, ssl: ..., user_agent: #http_user_agent, user: #http_user, password: #http_password" do
      expect(Ronin::Support::Network::HTTP).to receive(:connect).with(
        subject.host, subject.port, proxy:      subject.http_proxy,
                                    ssl:        base_url.scheme == 'https',
                                    user_agent: subject.http_user_agent
      )

      subject.http
    end

    it "must return a Ronin::Support::Network::HTTP instance" do
      expect(subject.http).to be_kind_of(Ronin::Support::Network::HTTP)
    end

    it "must return the same instance each time" do
      expect(subject.http).to be(subject.http)
    end
  end

  describe "#http_connect_uri" do
    context "when given no arguments" do
      it "must call Ronin::Support::Network::HTTP.connect with parms[:base_url], proxy: #http_proxy, ssl: ..., user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:connect_uri).with(
          subject.params[:base_url], proxy:      subject.http_proxy,
                                     ssl:        nil,
                                     user_agent: subject.http_user_agent
        )

        subject.http_connect_uri
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          allow(Ronin::Support::Network::HTTP).to receive(:connect_uri).with(
            subject.params[:base_url], proxy:      subject.http_proxy,
                                       ssl:        nil,
                                       user_agent: subject.http_user_agent
          )

          expect(subject).to receive(:print_debug).with(
            "Connecting to #{subject.params[:base_url]} ..."
          )

          subject.http_connect_uri
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_request" do
    context "when given a request method and a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with the request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:request).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_request(request_method,path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:request).with(
            request_method, url, proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Sending #{request_method.upcase} request to #{url} ..."
          )

          subject.http_request(request_method,path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end

    context "when given a request method and a URI" do
      let(:request_method) { :get }
      let(:uri)            { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the the request method, URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:request).with(
          request_method, uri, proxy:      subject.http_proxy,
                               ssl:        nil,
                               user_agent: subject.http_user_agent,
                               user:       subject.http_user,
                               password:   subject.http_password
        )

        subject.http_request(request_method,uri)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          allow(Ronin::Support::Network::HTTP).to receive(:request).with(
            request_method, uri, proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Sending #{request_method.upcase} request to #{uri} ..."
          )

          subject.http_request(request_method,uri)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_response_status" do
    context "when given a request method and a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_status).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password

        )

        subject.http_response_status(request_method,path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:response_status).with(
            request_method, url, proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Checking response status for #{request_method.upcase} #{url} ..."
          )

          subject.http_response_status(request_method,path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end

    context "when given a request method and a URI" do
      let(:request_method) { :get }
      let(:uri)            { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the request method, URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_status).with(
          request_method,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_response_status(request_method,uri)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          allow(Ronin::Support::Network::HTTP).to receive(:response_status).with(
            request_method, uri, proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Checking response status for #{request_method.upcase} #{uri} ..."
          )

          subject.http_response_status(request_method,uri)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_ok?" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with :head, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:ok?).with(
          :head, subject.url_for(path), proxy:      subject.http_proxy,
                                        ssl:        nil,
                                        user_agent: subject.http_user_agent,
                                        user:       subject.http_user,
                                        password:   subject.http_password
        )

        subject.http_ok?(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:ok?).with(
            :head, url, proxy:      subject.http_proxy,
                        ssl:        nil,
                        user_agent: subject.http_user_agent,
                        user:       subject.http_user,
                        password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Checking if response status for HEAD #{url} is 200 ..."
          )

          subject.http_ok?(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end

    context "when given a request method and a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:ok?).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_ok?(request_method,path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:ok?).with(
            request_method, url, proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Checking if response status for #{request_method.upcase} #{url} is 200 ..."
          )

          subject.http_ok?(request_method,path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_response_headers" do
    context "when given a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with :head, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_headers).with(
          :head,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_response_headers(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:response_headers).with(
            :head, url, proxy:      subject.http_proxy,
                        ssl:        nil,
                        user_agent: subject.http_user_agent,
                        user:       subject.http_user,
                        password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting response headers for HEAD #{url} ..."
          )

          subject.http_response_headers(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end

    context "when given a request method and a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_headers).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_response_headers(request_method,path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:response_headers).with(
            request_method, url, proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting response headers for #{request_method.upcase} #{url} ..."
          )

          subject.http_response_headers(request_method,path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_server_header" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with :head, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:server_header).with(
          subject.url_for(path),
          method:     :head,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_server_header(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:server_header).with(
            url, method:     :head,
                 proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting the 'Server' header for HEAD #{url} ..."
          )

          subject.http_server_header(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end

    context "when given a path and the method: keyword argument" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with method, #url_for(path), method: request_method, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:server_header).with(
          subject.url_for(path), method:     request_method,
                                 proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
        )

        subject.http_server_header(path, method: request_method)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:server_header).with(
            url, method:     request_method,
                 proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting the 'Server' header for #{request_method.upcase} #{url} ..."
          )

          subject.http_server_header(path, method: request_method)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_powered_by_header" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:powered_by_header).with(
          subject.url_for(path),
          method:     :head,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_powered_by_header(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:powered_by_header).with(
            url, method:     :head,
                 proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting the 'X-Powered-By' header for HEAD #{url} ..."
          )

          subject.http_powered_by_header(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end

    context "when given a path and a method: keyword argument" do
      let(:request_method) { :get   }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), method: request_method, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:powered_by_header).with(
          subject.url_for(path), method:     request_method,
                                 proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
        )

        subject.http_powered_by_header(path, method: request_method)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:powered_by_header).with(
            url, method:     request_method,
                 proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting the 'X-Powered-By' header for #{request_method.upcase} #{url} ..."
          )

          subject.http_powered_by_header(path, method: request_method)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_response_body" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with :get, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_body).with(
          :get, subject.url_for(path), proxy:      subject.http_proxy,
                                       ssl:        nil,
                                       user_agent: subject.http_user_agent,
                                       user:       subject.http_user,
                                       password:   subject.http_password
        )

        subject.http_response_body(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:response_body).with(
            :get, url, proxy:      subject.http_proxy,
                       ssl:        nil,
                       user_agent: subject.http_user_agent,
                       user:       subject.http_user,
                       password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting response body for GET #{url} ..."
          )

          subject.http_response_body(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end

    context "when given a request method and a path" do
      let(:request_method) { :head  }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_body).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_response_body(request_method,path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:response_body).with(
            request_method, url, proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting response body for #{request_method.upcase} #{url} ..."
          )

          subject.http_response_body(request_method,path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_copy" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:copy).with(
          subject.url_for(path), proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
        )

        subject.http_copy(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:copy).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting COPY #{url} ..."
          )

          subject.http_copy(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_delete" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:delete).with(
          subject.url_for(path), proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
        )

        subject.http_delete(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:delete).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting DELETE #{url} ..."
          )

          subject.http_delete(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_get" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:get).with(
          subject.url_for(path), proxy:      subject.http_proxy,
                                 ssl:        nil,
                                 user_agent: subject.http_user_agent,
                                 user:       subject.http_user,
                                 password:   subject.http_password
        )

        subject.http_get(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:get).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting GET #{url} ..."
          )

          subject.http_get(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_get_headers" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_headers).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_get_headers(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:get_headers).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting headers for GET #{url} ..."
          )

          subject.http_get_headers(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_get_cookies" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_cookies).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_get_cookies(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)
          
          allow(Ronin::Support::Network::HTTP).to receive(:get_cookies).with(
            url, proxy:      subject.http_proxy,
                  ssl:        nil,
                  user_agent: subject.http_user_agent,
                  user:       subject.http_user,
                  password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Getting cookies for #{url} ..."
          )

          subject.http_get_cookies(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_get_body" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_body).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_get_body(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:get_body).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting body for GET #{url} ..."
          )

          subject.http_get_body(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_head" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:head).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_head(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:head).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting HEAD #{url} ..."
          )

          subject.http_head(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_lock" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:lock).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_lock(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:lock).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting LOCK #{url} ..."
          )

          subject.http_lock(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_mkcol" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:mkcol).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_mkcol(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:mkcol).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting MKCOL #{url} ..."
          )

          subject.http_mkcol(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_move" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:move).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_move(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:move).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting MOVE #{url} ..."
          )

          subject.http_move(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_options" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:options).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_options(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:options).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting OPTIONS #{url} ..."
          )

          subject.http_options(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_allowed_methods" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:allowed_methods).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_allowed_methods(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:allowed_methods).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Checking allowed HTTP methods for #{url} ..."
          )

          subject.http_allowed_methods(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_patch" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:patch).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_patch(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:patch).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting PATCH #{url} ..."
          )

          subject.http_patch(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_post" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:post).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_post(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:post).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting POST #{url} ..."
          )

          subject.http_post(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_post_headers" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:post_headers).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_post_headers(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:post_headers).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting response headers for POST #{url} ..."
          )

          subject.http_post_headers(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_post_body" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:post_body).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_post_body(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:post_body).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting response body for POST #{url} ..."
          )

          subject.http_post_body(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_propfind" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:propfind).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_propfind(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:propfind).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting PROPFIND #{url} ..."
          )

          subject.http_propfind(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_proppatch" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:proppatch).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_proppatch(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          expect(Ronin::Support::Network::HTTP).to receive(:proppatch).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting PROPPATCH #{url} ..."
          )

          subject.http_proppatch(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_put" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:put).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_put(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:put).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting PUT #{url} ..."
          )

          subject.http_put(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_trace" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:trace).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_trace(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:trace).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting TRACE #{url} ..."
          )

          subject.http_trace(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end

  describe "#http_unlock" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent, user: #http_user, password: #http_password" do
        expect(Ronin::Support::Network::HTTP).to receive(:unlock).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent,
          user:       subject.http_user,
          password:   subject.http_password
        )

        subject.http_unlock(path)
      end

      context "when debug messages are enabled" do
        before { Ronin::Support::CLI::Printing.debug = true }

        it "must print a debugging message" do
          url = subject.url_for(path)

          allow(Ronin::Support::Network::HTTP).to receive(:unlock).with(
            url, proxy:      subject.http_proxy,
                 ssl:        nil,
                 user_agent: subject.http_user_agent,
                 user:       subject.http_user,
                 password:   subject.http_password
          )

          expect(subject).to receive(:print_debug).with(
            "Requesting UNLOCK #{url} ..."
          )

          subject.http_unlock(path)
        end

        after { Ronin::Support::CLI::Printing.debug = false }
      end
    end
  end
end
