require 'spec_helper'
require 'ronin/exploits/mixins/http'
require 'ronin/exploits/exploit'

describe Ronin::Exploits::Mixins::HTTP do
  module TestMixinsHTTP
    class TestExploit < Ronin::Exploits::Exploit
      include Ronin::Exploits::Mixins::HTTP
    end
  end

  let(:test_class) { TestMixinsHTTP::TestExploit }

  describe ".included" do
    subject { test_class }

    it "must define a 'proxy' param" do
      expect(subject.params[:proxy]).to_not be_nil
      expect(subject.params[:proxy].desc).to eq("The HTTP proxy to use")
    end

    it "must define a 'user_agent' param" do
      expect(subject.params[:user_agent]).to_not be_nil
      expect(subject.params[:user_agent].type).to be_kind_of(Ronin::Core::Params::Types::Enum)
      expect(subject.params[:user_agent].type.values).to eq(
        [
          :random,
          :chrome,
          :firefox,
          :safari,
          :linux,
          :macos,
          :windows,
          :iphone,
          :ipad,
          :android
        ] + Ronin::Support::Network::HTTP::UserAgents::ALIASES.keys
      )
      expect(subject.params[:user_agent].desc).to eq("The HTTP User-Agent to select")
    end

    it "must define a 'user_agent_string' param" do
      expect(subject.params[:user_agent_string]).to_not be_nil
      expect(subject.params[:user_agent_string].desc).to eq("The HTTP User-Agent string to use")
    end
  end

  let(:base_url) { URI.parse("https://www.example.com/base") }

  subject do
    test_class.new(params: {base_url: base_url})
  end

  describe "#url_for" do
    context "when given an absolute path" do
      let(:path) { '/foo' }

      it "must return a URI::HTTP object" do
        expect(subject.url_for(path)).to be_kind_of(URI::HTTP)
      end

      it "must override the path of the params[:base_url]" do
        expect(subject.url_for(path).path).to eq(path)
      end
    end

    context "when given a relative path" do
      let(:path) { 'foo' }

      it "must return a URI::HTTP object" do
        expect(subject.url_for(path)).to be_kind_of(URI::HTTP)
      end

      it "must convert the path into an absolute path" do
        expect(subject.url_for(path).path).to eq("/#{path}")
      end
    end

    context "when given a fully qualified URL" do
      let(:url) { "https://www.other.com/foo" }

      it "must return the URL" do
        expect(subject.url_for(url).to_s).to eq(url)
      end
    end
  end

  describe "#http_proxy" do
    let(:proxy) { 'http://example.com:8080' }

    subject do
      test_class.new(params: {base_url: base_url, proxy: proxy})
    end

    it "must return params[:proxy]" do
      expect(subject.http_proxy).to be(subject.params[:proxy])
    end
  end

  describe "#http_user_agent" do
    context "when params[:user_agent] is set" do
      let(:user_agent) { :random }

      subject do
        test_class.new(
          params: {
            base_url:   base_url,
            user_agent: user_agent
          }
        )
      end

      it "must return params[:user_agent]" do
        expect(subject.http_user_agent).to be(subject.params[:user_agent])
      end
    end

    context "when params[:user_agent_string] is set" do
      let(:user_agent_string) { 'Mozilla/5.0 Foo Bar' }

      subject do
        test_class.new(
          params: {
            base_url:          base_url,
            user_agent_string: user_agent_string
          }
        )
      end

      it "must return params[:user_agent_string]" do
        expect(subject.http_user_agent).to be(
          subject.params[:user_agent_string]
        )
      end
    end

    context "when both params[:user_agent] and params[:user_agent_string] are set" do
      let(:user_agent)        { :random }
      let(:user_agent_string) { 'Mozilla/5.0 Foo Bar' }

      subject do
        test_class.new(
          params: {
            base_url:          base_url,
            user_agent:        user_agent,
            user_agent_string: user_agent_string
          }
        )
      end

      it "must return params[:user_agent_string]" do
        expect(subject.http_user_agent).to be(
          subject.params[:user_agent_string]
        )
      end
    end
  end

  let(:proxy)             { URI('https://proxy.example.com:8080') }
  let(:user_agent_string) { 'Mozilla/5.0 Foo Bar' }

  subject do
    test_class.new(
      params: {
        base_url:          base_url,
        proxy:             proxy,
        user_agent_string: user_agent_string
      }
    )
  end

  describe "#http_connect" do
    context "when given no arguments" do
      it "must call Ronin::Support::Network::HTTP.connect with #host, #port, proxy: #http_proxy, ssl: ..., user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:connect).with(
          subject.host, subject.port, proxy:      subject.http_proxy,
                                      ssl:        base_url.scheme == 'https',
                                      user_agent: subject.http_user_agent
        )

        subject.http_connect
      end
    end
  end

  describe "#http_connect_uri" do
    context "when given no arguments" do
      it "must call Ronin::Support::Network::HTTP.connect with parms[:base_url], proxy: #http_proxy, ssl: ..., user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:connect_uri).with(
          subject.params[:base_url], proxy:      subject.http_proxy,
                                     ssl:        nil,
                                     user_agent: subject.http_user_agent
        )

        subject.http_connect_uri
      end
    end
  end

  describe "#http_request" do
    context "when given a request method and a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with the request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:request).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_request(request_method,path)
      end
    end

    context "when given a request method and a URI" do
      let(:request_method) { :get }
      let(:uri)            { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the the request method, URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:request).with(
          request_method,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_request(request_method,uri)
      end
    end
  end

  describe "#http_response_status" do
    context "when given a request method and a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_status).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_status(request_method,path)
      end
    end

    context "when given a request method and a URI" do
      let(:request_method) { :get }
      let(:uri)            { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the request method, URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_status).with(
          request_method,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_status(request_method,uri)
      end
    end
  end

  describe "#http_ok?" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with :head, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:ok?).with(
          :head,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_ok?(path)
      end
    end

    context "when given a request method and a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:ok?).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_ok?(request_method,path)
      end
    end

    context "when given a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the :head, uri, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:ok?).with(
          :head,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_ok?(uri)
      end
    end

    context "when given a request method and a URI" do
      let(:request_method) { :get }
      let(:uri)            { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the request method, uri, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:ok?).with(
          request_method,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_ok?(request_method,uri)
      end
    end
  end

  describe "#http_response_headers" do
    context "when given a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with :head, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_headers).with(
          :head,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_headers(path)
      end
    end

    context "when given a request method and a path" do
      let(:request_method) { :get }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_headers).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_headers(request_method,path)
      end
    end

    context "when given a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the :head, uri, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_headers).with(
          :head,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_headers(uri)
      end
    end

    context "when given a request method and a URI" do
      let(:request_method) { :get }
      let(:uri)            { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the request method, uri, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_headers).with(
          request_method,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_headers(request_method,uri)
      end
    end
  end

  describe "#http_server_header" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:server_header).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_server_header(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:server_header).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_server_header(uri)
      end
    end
  end

  describe "#http_powered_by_header" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:powered_by_header).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_powered_by_header(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:powered_by_header).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_powered_by_header(uri)
      end
    end
  end

  describe "#http_response_body" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with :get, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_body).with(
          :get,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_body(path)
      end
    end

    context "when given a request method and a path" do
      let(:request_method) { :head  }
      let(:path)           { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with request method, #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_body).with(
          request_method,
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_body(request_method,path)
      end
    end

    context "when given a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the :get, uri, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_body).with(
          :get,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_body(uri)
      end
    end

    context "when given a request method and a URI" do
      let(:request_method) { :head }
      let(:uri)            { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the request method, uri, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:response_body).with(
          request_method,
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_response_body(request_method,uri)
      end
    end
  end

  describe "#http_copy" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:copy).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_copy(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:copy).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_copy(uri)
      end
    end
  end

  describe "#http_delete" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:delete).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_delete(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:delete).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_delete(uri)
      end
    end
  end

  describe "#http_get" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:get).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_get(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:get).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_get(uri)
      end
    end
  end

  describe "#http_get_headers" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_headers).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_get_headers(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_headers).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_get_headers(uri)
      end
    end
  end

  describe "#http_get_cookies" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_cookies).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_get_cookies(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_cookies).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_get_cookies(uri)
      end
    end
  end

  describe "#http_get_body" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_body).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_get_body(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:get_body).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_get_body(uri)
      end
    end
  end

  describe "#http_head" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:head).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_head(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:head).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_head(uri)
      end
    end
  end

  describe "#http_lock" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:lock).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_lock(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:lock).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_lock(uri)
      end
    end
  end

  describe "#http_mkcol" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:mkcol).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_mkcol(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:mkcol).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_mkcol(uri)
      end
    end
  end

  describe "#http_move" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:move).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_move(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:move).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_move(uri)
      end
    end
  end

  describe "#http_options" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:options).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_options(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:options).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_options(uri)
      end
    end
  end

  describe "#http_allowed_methods" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:allowed_methods).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_allowed_methods(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:allowed_methods).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_allowed_methods(uri)
      end
    end
  end

  describe "#http_patch" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:patch).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_patch(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:patch).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_patch(uri)
      end
    end
  end

  describe "#http_post" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:post).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_post(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:post).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_post(uri)
      end
    end
  end

  describe "#http_post_headers" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:post_headers).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_post_headers(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:post_headers).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_post_headers(uri)
      end
    end
  end

  describe "#http_post_body" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:post_body).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_post_body(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:post_body).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_post_body(uri)
      end
    end
  end

  describe "#http_propfind" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:propfind).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_propfind(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:propfind).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_propfind(uri)
      end
    end
  end

  describe "#http_proppatch" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:proppatch).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_proppatch(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:proppatch).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_proppatch(uri)
      end
    end
  end

  describe "#http_put" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:put).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_put(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:put).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_put(uri)
      end
    end
  end

  describe "#http_trace" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:trace).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_trace(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:trace).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_trace(uri)
      end
    end
  end

  describe "#http_unlock" do
    context "when given a path" do
      let(:path) { '/foo' }

      it "must call Ronin::Support::Network::HTTP.connect with #url_for(path), proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:unlock).with(
          subject.url_for(path),
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_unlock(path)
      end
    end

    context "when given a request method and a URI" do
      let(:uri) { URI('https://www.other.com/foo') }

      it "must call Ronin::Support::Network::HTTP.connect with the URI, proxy: #http_proxy, ssl: nil, user_agent: #http_user_agent" do
        expect(Ronin::Support::Network::HTTP).to receive(:unlock).with(
          uri,
          proxy:      subject.http_proxy,
          ssl:        nil,
          user_agent: subject.http_user_agent
        )

        subject.http_unlock(uri)
      end
    end
  end
end
