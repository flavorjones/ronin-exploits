require 'spec_helper'
require 'ronin/exploits/exploit'

require 'helpers/exploits'
require 'helpers/payloads'

describe Exploits::Exploit do
  include Helpers

  let(:exploit) { load_exploit('simple') }

  it "should require a name attribute" do
    exp = described_class.new
    exp.should_not be_valid

    exp.name = 'test'
    exp.should be_valid
  end

  it "should have a unique name and version" do
    first_exp = described_class.create(
      name: 'test2',
      version: '0.0.1'
    )
    first_exp.should be_valid

    second_exp = described_class.new(
      name: 'test2',
      version: '0.0.1'
    )
    second_exp.should_not be_valid

    third_exp = described_class.new(
      name: 'test2',
      version: '0.0.2'
    )
    third_exp.should be_valid
  end

  describe "helpers" do
    it "should allow for the extending of Helper modules" do
      exploit.instance_eval { helper :padding }.should == true
    end

    it "should raise an UnknownHelper when extending an unknown helper" do
      lambda {
        exploit.instance_eval { helper :obvious_not_there }
      }.should raise_error(Exploits::UnknownHelper)
    end
  end

  describe "#use_target!" do
    after(:each) do
      exploit.target = nil
    end

    it "should select targets by architecture" do
      exploit.use_target! arch: :x86_64

      exploit.target.arch.should == Arch.x86_64
    end

    it "should select targets by Operating System" do
      exploit.use_target! os: 'Windows'

      exploit.target.os.name.should == 'Windows'
    end

    it "should select targets by Operating System and version" do
      exploit.use_target! os: ['Windows', '7.1']

      exploit.target.os.name.should == 'Windows'
      exploit.target.os.version.should == '7.1'
    end

    it "should select targets by Software" do
      exploit.use_target! software: 'ExampleWare'

      exploit.target.software.name.should == 'ExampleWare'
    end

    it "should select targets by Software and version" do
      exploit.use_target! software: ['ExampleWare', '1.5']

      exploit.target.software.name.should == 'ExampleWare'
      exploit.target.software.version.should == '1.5'
    end

    it "should select the first target if no options are specified" do
      exploit.use_target!

      exploit.target.arch.name.should == 'x86'
    end
  end

  it "should have a default target" do
    exploit.target.should_not be_nil

    exploit.target.arch.name.should == 'x86'

    exploit.target.os.name.should == 'Linux'
    exploit.target.os.version.should == '2.6.23'
  end

  it "should have a default targeted Arch" do
    exploit.arch.name.should == 'x86'
  end

  it "should have a default targeted OS" do
    exploit.os.name.should == 'Linux'
    exploit.os.version.should == '2.6.23'
  end

  it "should have a default targeted Software" do
    exploit.software.name.should == 'ExampleWare'
    exploit.software.version.should == '1.5'
  end

  describe "payload" do
    let(:payload) { load_payload('simple') }

    it "should set the payloads exploit when setting the payload" do
      payload.exploit.should be_nil

      exploit.payload = payload
      payload.exploit.should == exploit
    end

    it "should be able to set the payload to nil" do
      exploit.payload = payload
      exploit.payload = nil

      exploit.payload.should be_nil
    end

    it "should set the payload and the exploit of the payload to nil" do
      exploit.payload = payload
      exploit.payload = nil

      payload.exploit.should be_nil
    end

    describe "raw payload" do
      it "should build a raw payload" do
        exploit.payload = payload
        exploit.build_payload!

        exploit.raw_payload.should == 'code.func'
      end

      it "should pass options to the payload when building the raw payload" do
        exploit.payload = payload
        exploit.build_payload!(custom: 'test')

        exploit.raw_payload.should == 'code.test'
      end

      it "should default raw_payload to an empty String, if payload is nil" do
        exploit.payload = nil
        exploit.build_payload!

        exploit.raw_payload.should == ''
      end

      it "should not reset raw_payload, if payload is nil" do
        exploit.payload = nil
        exploit.raw_payload = 'data'

        exploit.build_payload!
        exploit.raw_payload.should == 'data'
      end
    end

    describe "encoding" do
      it "should have no payload encoders by default" do
        exploit.encoders.should be_empty
      end

      it "should accept blocks as payload encoders" do
        exploit.raw_payload = 'data'

        exploit.encode_payload do |payload|
          payload.capitalize
        end

        exploit.encode_payload!
        exploit.raw_payload.should == 'Data'
      end

      it "should accept an object with an #encode method" do
        exploit.raw_payload = 'data'
        exploit.encode_payload(Encoders::Encoder.new)

        exploit.encode_payload!
        exploit.raw_payload.should == 'data'
      end

      it "should not accept objects without an #encode method" do
        lambda {
          exploit.encode_payload(Object.new)
        }.should raise_error(ArgumentError)
      end

      it "should accept either a payload encoder object or a block" do
        lambda {
          exploit.encode_payload()
        }.should raise_error(ArgumentError)
      end

      it "should encode a String payload" do
        exploit.raw_payload = 'data'

        exploit.encode_payload!
        exploit.raw_payload.should == 'data'
      end

      it "should encode a String using encoders" do
        exploit.raw_payload = 'data'
        exploit.encoders << lambda { |payload| payload.upcase }

        exploit.encode_payload!
        exploit.raw_payload.should == 'DATA'
      end

      it "should ignore payload encoders which return nil" do
        exploit.raw_payload = 'data'
        exploit.encoders << lambda { |payload| nil }

        exploit.encode_payload!
        exploit.raw_payload.should == 'data'
      end
    end

    it "should deploy the payload after deploying the exploit" do
      exploit.payload = payload
      payload.should_not be_deployed

      exploit.build!
      exploit.deploy! do
        exploit.payload.should be_deployed
      end
    end

    it "should pass missing methods to the payload" do
      exploit.payload = payload
      exploit.some_method.should == :some_result
    end
  end

  describe "#exploit!" do
    it "should build and deploy the exploit when exploited" do
      exploit.exploit!

      exploit.should be_built
      exploit.should be_deployed
    end

    it "should not deploy during a dry-run of the exploit" do
      exploit.exploit!(dry_run: true)

      exploit.should be_built
      exploit.should_not be_deployed
    end
  end
end
