require 'spec_helper'
require 'ronin/exploits/exploit'

require 'helpers/exploits'
require 'helpers/payloads'

describe Exploits::Exploit do
  include Helpers

  let(:exploit) { load_exploit('simple') }

  it "should require a name attribute" do
    exp = described_class.new
    expect(exp).not_to be_valid

    exp.name = 'test'
    expect(exp).to be_valid
  end

  it "should have a unique name and version" do
    first_exp = described_class.create(
      name: 'test2',
      version: '0.0.1'
    )
    expect(first_exp).to be_valid

    second_exp = described_class.new(
      name: 'test2',
      version: '0.0.1'
    )
    expect(second_exp).not_to be_valid

    third_exp = described_class.new(
      name: 'test2',
      version: '0.0.2'
    )
    expect(third_exp).to be_valid
  end

  describe "#use_target!" do
    after(:each) do
      exploit.target = nil
    end

    it "should select targets by architecture" do
      exploit.use_target! arch: :x86_64

      expect(exploit.target.arch).to eq(Arch.x86_64)
    end

    it "should select targets by Operating System" do
      exploit.use_target! os: 'Windows'

      expect(exploit.target.os.name).to eq('Windows')
    end

    it "should select targets by Operating System and version" do
      exploit.use_target! os: ['Windows', '7.1']

      expect(exploit.target.os.name).to eq('Windows')
      expect(exploit.target.os.version).to eq('7.1')
    end

    it "should select targets by Software" do
      exploit.use_target! software: 'ExampleWare'

      expect(exploit.target.software.name).to eq('ExampleWare')
    end

    it "should select targets by Software and version" do
      exploit.use_target! software: ['ExampleWare', '1.5']

      expect(exploit.target.software.name).to eq('ExampleWare')
      expect(exploit.target.software.version).to eq('1.5')
    end

    it "should select the first target if no options are specified" do
      exploit.use_target!

      expect(exploit.target.arch.name).to eq('x86')
    end
  end

  it "should have a default target" do
    expect(exploit.target).not_to be_nil

    expect(exploit.target.arch.name).to eq('x86')

    expect(exploit.target.os.name).to eq('Linux')
    expect(exploit.target.os.version).to eq('2.6.23')
  end

  it "should have a default targeted Arch" do
    expect(exploit.arch.name).to eq('x86')
  end

  it "should have a default targeted OS" do
    expect(exploit.os.name).to eq('Linux')
    expect(exploit.os.version).to eq('2.6.23')
  end

  it "should have a default targeted Software" do
    expect(exploit.software.name).to eq('ExampleWare')
    expect(exploit.software.version).to eq('1.5')
  end

  describe "payload" do
    let(:payload) { load_payload('simple') }

    it "should set the payloads exploit when setting the payload" do
      expect(payload.exploit).to be_nil

      exploit.payload = payload
      expect(payload.exploit).to eq(exploit)
    end

    it "should be able to set the payload to nil" do
      exploit.payload = payload
      exploit.payload = nil

      expect(exploit.payload).to be_nil
    end

    it "should set the payload and the exploit of the payload to nil" do
      exploit.payload = payload
      exploit.payload = nil

      expect(payload.exploit).to be_nil
    end

    describe "raw payload" do
      it "should build a raw payload" do
        exploit.payload = payload
        exploit.build_payload!

        expect(exploit.raw_payload).to eq('code.func')
      end

      it "should pass options to the payload when building the raw payload" do
        exploit.payload = payload
        exploit.build_payload!(custom: 'test')

        expect(exploit.raw_payload).to eq('code.test')
      end

      it "should default raw_payload to an empty String, if payload is nil" do
        exploit.payload = nil
        exploit.build_payload!

        expect(exploit.raw_payload).to eq('')
      end

      it "should not reset raw_payload, if payload is nil" do
        exploit.payload = nil
        exploit.raw_payload = 'data'

        exploit.build_payload!
        expect(exploit.raw_payload).to eq('data')
      end
    end

    describe "encoding" do
      it "should have no payload encoders by default" do
        expect(exploit.encoders).to be_empty
      end

      it "should accept blocks as payload encoders" do
        exploit.raw_payload = 'data'

        exploit.encode_payload do |payload|
          payload.capitalize
        end

        exploit.encode_payload!
        expect(exploit.raw_payload).to eq('Data')
      end

      it "should accept an object with an #encode method" do
        exploit.raw_payload = 'data'
        exploit.encode_payload(Encoders::Encoder.new)

        exploit.encode_payload!
        expect(exploit.raw_payload).to eq('data')
      end

      it "should not accept objects without an #encode method" do
        expect {
          exploit.encode_payload(Object.new)
        }.to raise_error(ArgumentError)
      end

      it "should accept either a payload encoder object or a block" do
        expect {
          exploit.encode_payload()
        }.to raise_error(ArgumentError)
      end

      it "should encode a String payload" do
        exploit.raw_payload = 'data'

        exploit.encode_payload!
        expect(exploit.raw_payload).to eq('data')
      end

      it "should encode a String using encoders" do
        exploit.raw_payload = 'data'
        exploit.encoders << lambda { |payload| payload.upcase }

        exploit.encode_payload!
        expect(exploit.raw_payload).to eq('DATA')
      end

      it "should ignore payload encoders which return nil" do
        exploit.raw_payload = 'data'
        exploit.encoders << lambda { |payload| nil }

        exploit.encode_payload!
        expect(exploit.raw_payload).to eq('data')
      end
    end

    it "should deploy the payload after deploying the exploit" do
      exploit.payload = payload
      expect(payload).not_to be_deployed

      exploit.build!
      exploit.deploy! do
        expect(exploit.payload).to be_deployed
      end
    end

    it "should pass missing methods to the payload" do
      exploit.payload = payload
      expect(exploit.some_method).to eq(:some_result)
    end
  end

  describe "#exploit!" do
    it "should build and deploy the exploit when exploited" do
      exploit.exploit!

      expect(exploit).to be_built
      expect(exploit).to be_deployed
    end

    it "should not deploy during a dry-run of the exploit" do
      exploit.exploit!(dry_run: true)

      expect(exploit).to be_built
      expect(exploit).not_to be_deployed
    end
  end
end
