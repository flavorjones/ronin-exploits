require 'spec_helper'

require 'ronin/exploits/sqli'

describe Exploits::SQLi do
  let(:host)                { 'testasp.vulnweb.com' }
  let(:path)                { '/showthread.asp' }
  let(:query_param)         { 'id' }
  let(:query_param_value)   { '2' }
  let(:query)               { "#{query_param}=#{query_param_value}" }

  let(:exploit) do
    described_class.new(
      :host            => host,
      :url_path        => path,
      :url_query       => query,
      :url_query_param => {:name => query_param}
    )
  end
  subject { exploit }

  describe "#quotes" do
    it "shoulde default to 'single'" do
      subject.quotes.should == 'single'
    end
  end

  describe "#terminate" do
    it "should default to false" do
      subject.terminate.should be_false
    end
  end

  describe "#url_query_param_value" do
    it "should extract the value of the target query-param" do
      subject.url_query_param_value.should == query_param_value
    end

    context "when url_query does not contain the target query-param" do
      before { subject.url_query = '' }

      it "should return ''" do
        subject.url_query_param_value.should be_empty
      end
    end
  end

  describe "#escape_sql" do
    let(:sql)     { Code.sql[:or, 1, :eq, 1] }
    let(:raw_sql) { 'OR 1=1' }

    context "escaping integers" do
      before { subject.escape = 'integer' }

      it "should add a space after the url_query_param_value" do
        sqli = subject.escape_sql(sql)

        sqli.should be_start_with(subject.url_query_param_value + ' ')
      end
    end

    context "escaping strings" do
      before { subject.escape = 'string' }

      it "should include a quote and a space after the url_query_param_value" do
        sqli = subject.escape_sql(sql)

        sqli.should be_start_with(subject.url_query_param_value + "' ")
      end

      context "when not terminating" do
        context "and the SQL ends with a quote" do
          let(:sql) { Code.sql['1', :eq, '1'] }

          it "should remove the tailing quote" do
            sqli = subject.escape_sql(sql)

            sqli.should_not be_end_with("'")
          end
        end

        context "otherwise" do
          it "should append \" and '\"" do
            sqli = subject.escape_sql(sql)
            
            sqli.should be_end_with(" and '")
          end
        end
      end
    end

    context "escaping parenthesis" do
      before { subject.escape = 'parenthesis' }

      let(:sqli) { subject.escape_sql(sql) }

      it "should include a parenthesis after the url_query_param_value" do
        sqli.should be_start_with(subject.url_query_param_value + ')')
      end

      it "should terminate the SQLi" do
        sqli.should be_end_with('--')
      end
    end

    context "escaping statements" do
      before { subject.escape = 'statement' }

      let(:sqli) { subject.escape_sql(sql) }

      it "should include a semicolon after the url_query_param_value" do
        sqli.should be_start_with(subject.url_query_param_value + ';')
      end

      it "should terminate the SQLi" do
        sqli.should be_end_with('--')
      end
    end

    context "when terminating" do
      before { subject.terminate = true }

      it "should append a single-line SQL comment" do
        sqli = subject.escape_sql("or 1=1")

        sqli.should be_end_with('--')
      end

      it "should not append a SQL comment, if one already exists" do
        sqli = subject.escape_sql("or 1=1--")

        sqli.should_not be_end_with('----')
      end
    end
  end

  describe "#exploit_url" do
    let(:sql)         { "OR 1=1" }
    let(:escaped_sql) { subject.escape_sql(sql) }

    it "should set the query_param to the escaped SQL" do
      uri = subject.exploit_url(sql)

      uri.query_params[query_param].should == escaped_sql
    end
  end

  describe "#test_quotes", :network => true do
    it "should test quote-marks for 500 responses" do
      subject.test_quotes.should be_true
    end
  end

  describe "#test_and_false", :network => true do
    it "should test \"AND 1=0\" for responses with less data" do
      subject.test_and_false.should be_true
    end
  end

  describe "#test_or_true", :network => true do
    it "should test \"OR 1=1\" for responses with more data" do
      subject.test_or_true.should be_true
    end
  end

  describe "#vulnerable?", :network => true do
    it "should determine if SQL can be injected" do
      subject.should be_vulnerable
    end
  end
end
