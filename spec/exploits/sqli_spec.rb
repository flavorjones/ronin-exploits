require 'spec_helper'

require 'ronin/exploits/sqli'

describe Exploits::SQLi do
  let(:host)                { 'testasp.vulnweb.com' }
  let(:path)                { '/showthread.asp' }
  let(:query_param)         { 'id' }
  let(:query_param_value)   { '2' }
  let(:query)               { "#{query_param}=#{query_param_value}" }

  let(:exploit) do
    described_class.new(
      :host            => host,
      :url_path        => path,
      :url_query       => query,
      :url_query_param => {:name => query_param}
    )
  end

  subject { exploit }

  describe "defaults" do
    its(:quotes)    { should == 'single' }
    its(:terminate) { should be(false) }
  end

  describe "#place_holder" do
    it "should return an Integer" do
      subject.place_holder.should == query_param_value.to_i
    end

    context "when escape is 'decimal'" do
      before { subject.escape = 'decimal' }

      it "should return a Float" do
        subject.place_holder.should == query_param_value.to_f
      end
    end

    context "when escape is 'string'" do
      before { subject.escape = 'string' }

      it "should return a String" do
        subject.place_holder.should == query_param_value
      end
    end

    context "when escape is 'list'" do
      before { subject.escape = 'list' }

      context "and url_query_param_value is an integer value" do
        let(:query_param_value) { '2' }

        it "should return an Array containing an Integer" do
          subject.place_holder.should == [query_param_value.to_i]
        end
      end

      context "and url_query_param_value is a decimal value" do
        let(:query_param_value) { '2.0' }

        it "should return an Array containing a Float" do
          subject.place_holder.should == [query_param_value.to_f]
        end
      end

      context "and url_query_param_value is a string value" do
        let(:query_param_value) { 'A' }

        it "should return an Array containing a String" do
          subject.place_holder.should == [query_param_value]
        end
      end
    end

    context "when escape is 'column'" do
      before { subject.escape = 'column' }

      it "should return a Symbol" do
        subject.place_holder.should == query_param_value.to_sym
      end
    end
  end

  describe "#exploit_url" do
    context "when passed a object that responds to #to_sql" do
      let(:sql)     { subject.sqli.or { 1 == 1 } }
      let(:raw_sql) { sql.to_sql }

      it "should set the query_param to the formatted SQL" do
        uri = subject.exploit_url(sql)

        uri.query_params[query_param].should == raw_sql
      end

      context "when terminate is true" do
        before { subject.terminate = true }

        let(:raw_sql) { sql.to_sql(terminate: true) }

        it "should terminate the SQL" do
          uri = subject.exploit_url(sql)

          uri.query_params[query_param].should == raw_sql
        end
      end
    end

    context "otherwise" do
      let(:sql)     { 1 }
      let(:raw_sql) { '1' }

      it "should convert the SQL to a String" do
        uri = subject.exploit_url(sql)

        uri.query_params[query_param].should == raw_sql
      end
    end
  end

  describe "#test_quotes", :network => true do
    it "should test quote-marks for 500 responses" do
      subject.test_quotes.should be_true
    end
  end

  describe "#test_and_false", :network => true do
    it "should test \"AND 1=0\" for responses with less data" do
      subject.test_and_false.should be_true
    end
  end

  describe "#test_or_true", :network => true do
    it "should test \"OR 1=1\" for responses with more data" do
      subject.test_or_true.should be_true
    end
  end

  describe "#vulnerable?", :network => true do
    it "should determine if SQL can be injected" do
      subject.should be_vulnerable
    end
  end
end
