#
# ronin-exploits - A Ruby library for ronin-rb that provides exploitation and
# payload crafting functionality.
#
# Copyright (c) 2007-2022 Hal Brodigan (postmodern.mod3 at gmail.com)
#
# This file is part of ronin-exploits.
#
# ronin-exploits is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ronin-exploits is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with ronin-exploits.  If not, see <https://www.gnu.org/licenses/>.
#

require 'ronin/exploits/cli/exploit_command'

require 'ronin/core/cli/printing/metadata'
require 'ronin/core/cli/printing/arch'
require 'ronin/core/cli/printing/os'
require 'ronin/core/metadata/version'

require 'command_kit/printing/fields'

module Ronin
  module Exploits
    class CLI
      module Commands
        #
        # Prints information about an exploit.
        #
        # ## Usage
        #
        #     ronin-exploits show [options] {NAME | --file FILE}
        #
        # ## Options
        #
        #     -f, --file FILE                  The exploit file to load
        #     -v, --verbose                    Enables verbose output
        #     -h, --help                       Print help information
        #
        # ## Arguments
        # 
        #     [NAME]                           The exploit name to load
        #
        class Show < ExploitCommand

          include Core::CLI::Printing::Metadata
          include Core::CLI::Printing::Arch
          include Core::CLI::Printing::OS
          include CommandKit::Printing::Fields

          description 'Prints information about an exploit'

          man_page 'ronin-exploits-show.1'

          #
          # Runs the `ronin-exploits show` command.
          #
          # @param [String] name
          #   The optional name of the exploit to load and print metadata about.
          #
          def run(name=nil)
            super(name)

            print_exploit(exploit_class)
          end

          #
          # Prints the exploit class'es metadata.
          #
          # @param [Class<Exploit>] exploit
          #   The loaded exploit class.
          #
          def print_exploit(exploit)
            puts "[ #{exploit.id} ]"
            puts

            indent do
              fields = {}

              fields['Type'] = exploit_type(exploit)

              if defined?(Core::Metadata::Version) &&
                 exploit.include?(Core::Metadata::Version)
                fields['Version'] = exploit.version if exploit.version
              end

              fields['Quality']   = exploit.quality   if exploit.quality
              fields['Released']  = exploit.release_date  if exploit.release_date
              fields['Disclosed'] = exploit.disclosure_date if exploit.disclosure_date

              if defined?(Mixins::HasPayload) &&
                 exploit.include?(Mixins::HasPayload)
                fields['Payload Type'] = payload_type(exploit.payload_class)
              end

              fields['Summary']   = exploit.summary   if exploit.summary
              print_fields(fields)

              unless exploit.advisories.empty?
                puts "Advisories:"
                puts

                indent do
                  exploit.advisories.each do |advisory|
                    print_advisory(advisory)
                  end
                end
                puts
              end

              print_authors(exploit)
              print_description(exploit)
              print_references(exploit)

              if defined?(Mixins::HasTargets) &&
                 exploit.include?(Mixins::HasTargets)
                unless exploit.targets.empty?
                  exploit.targets.each_with_index do |target,index|
                    puts "[ Target ##{index+1} ]"
                    puts

                    indent { print_target(target) }
                  end
                end
              end

              if defined?(Metadata::Shouts) &&
                 exploit.include?(Metadata::Shouts)
                puts "Shouts: #{exploit.shouts.join(', ')}"
              end
            end
          end

          #
          # Returns the printable exploit type for the exploit class.
          #
          # @param [Class<Exploit>] exploit_class
          #
          # @return [String]
          #
          def exploit_type(exploit_class)
            if defined?(MemoryCorruption) && exploit_class < MemoryCorruption
              if defined?(StackOverflow) && exploit_class < StackOverflow
                'Stack Overflow'
              elsif defined?(HeapOverflow) && exploit_class < HeapOverflow
                'Heap Overflow'
              elsif defined?(UseAfterFree) && exploit_class < UseAfterFree
                'Use After Free (UAF)'
              else
                'Memory Corruption'
              end
            elsif defined?(Web) && exploit_class < Web
              if defined?(LFI) && exploit_class < LFI
                'Local File Inclusion (LFI)'
              elsif defined?(RFI) && exploit_class < RFI
                'Remote file Inclusion (RFI)'
              elsif defined?(SQLi) && exploit_class < SQLi
                'SQL injection (SQLi)'
              end
            else
              'custom'
            end
          end

          #
          # Converts the exploit's payload class into a printable payload type
          # name.
          #
          # @param [Class<Ronin::Core::Payloads::Payload>] payload_class
          #
          # @return [String]
          #
          def payload_type(payload_class)
            if defined?(Payloads::HTMLPayload) &&
               payload_class <= Payloads::HTMLPayload
              'HTML'
            elsif defined?(Payloads::XMLPayload) &&
                  payload_class <= Payloads::XMLPayload
              'XML'
            elsif defined?(Payloads::SQLPayload) &&
                  payload_class <= Payloads::SQLPayload
              'SQL'
            elsif defined?(Payloads::ShellPayload) &&
                  payload_class <= Payloads::ShellPayload
              'shell'
            elsif defined?(Payloads::PowerShellPayload) &&
                  payload_class <= Payloads::PowerShellPayload
              'PowerShell'
            elsif defined?(Payloads::CPayload) &&
                  payload_class <= Payloads::CPayload
              'C'
            elsif defined?(Payloads::JavaPayload) &&
                  payload_class <= Payloads::JavaPayload
              'Java'
            elsif defined?(Payloads::ColdFusionPayload) &&
                  payload_class <= Payloads::ColdFusionPayload
              'ColdFusion'
            elsif defined?(Payloads::PHPPayload) &&
                  payload_class <= Payloads::PHPPayload
              'PHP'
            elsif defined?(Payloads::NodeJSPayload) &&
                  payload_class <= Payloads::NodeJSPayload
              if defined?(Payloads::Mixins::TypeScript) &&
                  payload_class.include?(Payloads::Mixins::TypeScript)
                'Node.js (TypeScript)'
              else
                'Node.js'
              end
            elsif defined?(Payloads::JavaScriptPayload) &&
                  payload_class <= Payloads::JavaScriptPayload
              if defined?(Payloads::Mixins::TypeScript) &&
                  payload_class.include?(Payloads::Mixins::TypeScript)
                'JavaScript (TypeScript)'
              else
                'JavaScript'
              end
            elsif defined?(Payloads::BinaryPayload) &&
                  payload_class <= Payloads::BinaryPayload
              if defined?(Payloads::ShellcodePayload) &&
                 payload_class <= Payloads::ShellcodePayload
                'shellcode'
              elsif defined?(Payloads::ASMPayload) &&
                    payload_class <= Payloads::ASMPayload
                'ASM'
              else
                'binary'
              end
            else
              'custom'
            end
          end

          #
          # Prints an advisory.
          #
          # @param [Advisory] advisory
          #   The advisory to print.
          #
          def print_advisory(advisory)
            if advisory.url then puts "* #{advisory.id} (#{advisory.url})"
            else                 puts "* #{advisory.id}"
            end
          end

          #
          # Prints an exploit target.
          #
          # @param [Target] target
          #   A target defined on the exploit.
          #
          def print_target(target)
            fields = {}
            fields['Arch'] = target.arch if target.arch

            if target.os
              fields['OS'] = if target.os_version
                               "#{target.os} #{target.os_version}"
                             else
                               target.os
                             end
            end

            if target.software
              fields['Software'] = if target.software_version
                                     "#{target.software} #{target.software_version}"
                                   else
                                     target.software
                                   end
            end

            print_fields(fields)

            if verbose?
              unless target.empty?
                puts "Params:"

                indent { print_fields(target.to_h) }
              end
            end

            puts
          end

        end
      end
    end
  end
end
