#
# Ronin Exploits - A Ruby library for Ronin that provides exploitation and
# payload crafting functionality.
#
# Copyright (c) 2007-2012 Hal Brodigan (postmodern.mod3 at gmail.com)
#
# This file is part of Ronin Exploits.
#
# Ronin is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ronin is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ronin.  If not, see <http://www.gnu.org/licenses/>
#

require 'ronin/attacks/web'
require 'ronin/code/sql'

module Ronin
  module Attacks
    #
    # Represents SQL Injection (SQLi) attacks.
    #
    # @since 1.0.0
    #
    class SQLi < Web

      # The type of escaping technique to use
      property :escape, String, :set => ['integer', 'string', 'statement']

      # The type of String quotation to use
      property :quotes, String, :set => ['single', 'double', 'backtick']

      # Whether or not to terminate the String with a SQL comment
      property :terminate, Boolean

      # Controls case-randomization of table/function names
      parameter :case, :type => Symbol

      # Controls whether to hex-escape the SQL string
      parameter :hex_escape, :type => true 

      # Controls whether less or more parenthesis are included in the SQL
      parameter :parens, :type => Symbol

      # Controls whether spaces or other kinds of white-space are used to
      # separate keywords.
      parameter :space, :type => String

      #
      # Prepares a SQL fragment for injection.
      #
      # @param [#to_sqli, #to_s] sql
      #   The SQL fragment.
      #
      # @return [String]
      #   The prepared SQL injection.
      #
      # @api semipublic
      #
      def inject(sql)
        if sql.respond_to?(:to_sqli)
          sql.to_sqli(
            :escape     => self.escape.to_sym,
            :value      => self.original_data,
            :terminate  => self.terminate,

            :case       => self.case,
            :quotes     => self.quotes.to_sym,
            :hex_escape => self.hex_escape,
            :parens     => self.parens,
            :space      => self.space
          )
        else
          sql.to_s
        end
      end

      #
      # Tests for SQL injection by appending ` AND 1=0`.
      #
      # @return [Boolean]
      #   Specifies if SQL injection was detected.
      #
      def test_and_false
        normal_body.length > exploit!(' AND 1=0')
      end

      #
      # Tests for SQL injection by appending ` OR 1=1`.
      #
      # @return [Boolean]
      #   Specifies if SQL injection was detected.
      #
      def test_or_true
        normal_body.length < exploit!(' OR 1=1')
      end

      #
      # Tests whether the URL is vulnerable to SQL injection.
      #
      # @return [Boolean]
      #   Specifies if SQL injection was detected.
      #
      # @see #test_and_false
      # @see #test_or_true
      #
      def vulnerable?
        test_and_false ||
        test_or_true
      end

    end
  end
end
